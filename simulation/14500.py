#테트로미노(14500)
#가능한 테트로미노 좌표 19가지를 모두 리스트로 정의한다.
#이중 for 문을 통해 한 좌표에 대해 가능한 모든 테트로미노를 검사한다.
#max값을 계속 갱신하면서 최종 최대값을 구한다.
#테트로미노가 board의 좌표를 벗어나는 경우는 try, except를 통해 쉽게 처리한다.

N, M = map(int, input().split())

board = [[int(x) for x in input().split()]for y in range(N)]
result = []

point = [[[0, 1], [0, 2], [0, 3]], [[1, 0], [2, 0], [3, 0]], [[0, 1], [1, 1], [1, 0]], [[1, 0], [2, 0], [2, 1]],
         [[1, 0], [2, 0], [2, -1]], [[0, 1], [1, 0], [2, 0]], [[0, 1], [1, 1], [2, 1]], [[0, 1], [0, 2], [1, 0]],
         [[0, 1], [0, 2], [-1, 2]], [[1, 0], [1, 1], [1, 2]], [[0, 1], [0, 2], [1, 2]], [[0, 1], [0, 2], [1, 1]],
         [[0, 1], [0, 2], [-1, 1]], [[1, 0], [2, 0], [1, 1]], [[1, 0], [2, 0], [1, -1]], [[1, 0], [1, -1], [2, -1]],
         [[1, 0], [1, 1], [2, 1]], [[0, 1], [-1, 1], [-1, 2]], [[0, 1], [1, 1], [1, 2]]]

for i in range(N):
    for j in range(M):
        for k in point:
            try:
                A = board[i + k[0][0]][j + k[0][1]]
                B = board[i + k[1][0]][j + k[1][1]]
                C = board[i + k[2][0]][j + k[2][1]]
                result.append(board[i][j] + A + B + C)
            except:
                continue

print(max(result))
