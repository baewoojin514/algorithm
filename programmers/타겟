#타겟 넘버(programmers)
#index를 증가 시킬 때마다 이전에 가능한 숫자에 2배에 해당하는 수가 + - 연산에 의해 발생한다.
#이 모든 경우의 수들을 리스트에 저장하고 마지막 index에 의해 발생한 수 만큼 슬라이싱 해서 그중 target의 수를 count한다.
#문제 풀이에는 성공하였지만 바람직한 풀이는 아니다.

import math
def solution(numbers, target):
    valid = []
    for i in numbers:
        temp = []
        temp.append(i)
        temp.append(-i)
        valid.append(temp)
    length = len(valid)

    sumlist = valid[0]
    temp = []
    for i in range(1, len(valid)):
        sum = sumlist[-(int(math.pow(2, i))):]
        for j in sum:
            for k in valid[i]:
                sumlist.append(j + k)
                temp.append(j+k)

    result = temp[-(int(math.pow(2, length))):]

    return result.count(target)
#타겟 넘버(programmers)
#dfs 재귀 방식을 통해 현재 값에 다음 값을 더하거나 뺀 수를 재귀 함수의 parameter로 넘긴다.
#재귀 함수 처음에 입력으로 들어온 모든 숫자를 더하거나 뺏는지 확인하고 그 수가 target과 같은지 확인한다.
#skill.1 - 함수 내부에 또 다른 함수를 선언하고 nonlocal을 통해 함수 외부에 있는 변수에 접근 가능하다.
#skill.2 - 함수 사용시 늘 변수 범위에 신경을 써야 한다.

def solution(numbers, target):
    answer = 0
    depth = len(numbers)

    def targetsearch(index, cNum):
        if index == depth:
            if cNum == target:
                nonlocal answer
                answer += 1
        else:
            targetsearch(index + 1, cNum + numbers[index])
            targetsearch(index + 1, cNum - numbers[index])

    targetsearch(0, 0)
    return answer
